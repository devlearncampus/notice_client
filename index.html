<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
     <style>
        body{
            margin: 0px;
        }
        #wrapper{
            width:100%;
            height:800px;
            background-color: antiquewhite;
        }
        .aside{
            width: 20%;
            height: 100%;
            background-color: aqua;
            float:left;
        }
        .aside *{
            width: 90%;
            margin:5px;
        }
        textarea{
            height:150px;
        }
        .content{
            width: 60%;
            height:100%;
            float: left;
        }
        .detail{
            width: 20%;
            height: 100%;
            background-color: beige;
            float: left;
        }
        .detail *{
            width: 90%;
            margin:5px;            
        }
        table{
            border-collapse: collapse;
            width:100%;
        }
        table, th, td{
            border:1px solid #ccc;
        }
        th, td{
            padding:8px;
        }
     </style>
     <script>
        /*
        React 의 2가지 개발 방식 
        1) Vite 프로젝트 개발방식 :  실제 Production 모드, 규모가 클 경우

        2) CDN 링크 방식 : 학습, 연구 , 테스트 목적, 규모가 작을 경우 
        */
     </script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>
<body>
    <!-- 게시판 애플리케이션이 표현될 영역 -->
    <div id="app"></div>

    <script type="text/babel">

        //좌측의 글등록 디자인을 컴포넌트화 시켜놓은 RegistForm
        //개발자가 컴포넌트 안에  매개변수로 전달할 수 잇는 데이터를 가리켜 props 라 부른다
        function RegistForm(props){
            const [title, setTitle] = React.useState("");
            const [writer, setWriter] = React.useState("");
            const [content, setContent] = React.useState("");
            
            //아래의 메서드에서 서버에 요청 로직을 작성할 수도 있지만, 우리는 SPA(Single Page Application=새로고침없는 사이트)
            //예정이므로, 게시물 등록에서 끝나는 것이 아니라, 목록, 상세, 수정, 삭제 요청을 하려면 변수 또는 메서드가 서로 공유되어야 
            //개발이 편하다. 따라서 변수, 메서드를 자식 컴포넌트에 로직을 두지 않고, 부모 컴포넌트에 둬야 개발이 용이함..
            function handleClick(){

                //글등록 요청시 넘게될 notice 생성 
                const notice={
                    title:title,
                    writer:writer,
                    content:content
                }    

                //자식 컴포넌트는 부모의 메서드를 직접 접근할 수 없다...
                //해결책은? 자식 컴포넌트에 props로 부모의 메서드명을 전달해주면 된다..즉 props를 이용한 정보 전달 방법을 사용 
                props.onRegist(notice);//부모 컴포넌트 메서드 호출 가능?//regist(notice)
            }   

            return (
                <div className="aside">
                    <form>                        
                        <input type="text" placeholder="제목 입력" onChange={ e=> setTitle(e.target.value) }/>
                        <input type="text" placeholder="작성자 입력" onChange={ e=> setWriter(e.target.value) }/>        
                        <textarea onChange={ e=> setContent(e.target.value) }></textarea>
                        <button type="button" onClick={handleClick}>{props.bt}</button>
                    </form>    
                </div>
            );
        }

        //가운데 게시물 목록이 나올 영역을 컴포넌트로 정의 
        function NoticeList(props){//자식 컴포넌트가 부모 컴포넌트의 변수, 메서드를 직접 접근할 수 없으므로, 주로 props를 이용하여
            //전달 받자..여기서는 noticeList를 전달받을 예정임..
            return (
                <div className="content">
                    <table>
                        <thead>
                            <tr>
                                <th>No</th>
                                <th>제목</th>
                                <th>작성자</th>
                                <th>등록일</th>
                                <th>조회수</th>
                            </tr>
                        </thead>
                        <tbody>
                            {/* map()은 어디서 온건가? js의 배열 메서드 중 하나.. 선언적 프로그래밍 중 함수형 프로그래밍의 원칙 적용 
                                눈에 보이지 않지만, 반복문을 스스로 수행함 , 개발자는 몇번째 반복인지 중간에 개입불가..개발자는 그냥 
                                어떤 업무를 원하는지 선언만 하는 프로그래밍 방식..
                            */}
                            { props.noticeList.map( notice => (
                                <tr key={notice.noticeId} onClick={ ()=> props.onSelectOne(notice) } style={{cursor:"pointer"}}>
                                    <td>sdf</td>                                    
                                    <td>{notice.title}</td>
                                    <td>{notice.writer}</td>
                                    <td>{notice.regdate}</td>
                                    <td>{notice.hit}</td>
                                </tr>
                                 ))
                            }    
                        </tbody>        
                    </table>                            
                </div>
            );
        }

        //우측 게시물 내용이 나올 영역을 컴포넌트로 정의 
        //자식 컴포넌트가 부모의 변수나 메서드를 접근하려면 props를 이용할 수 있다..
        //현재 우리의 경우, 게시물 한건을 표현한  notice를 이 컴포넌트가 바인딩되어 바라보게 되면, 개발자가 notice정보를 변경만 해도
        //자동으로 UI에 영향을 미친다...(리엑트, Vue를 사용하는 이유이다..즉 개발자가 데이터에만 집중하면 되고, UI를 수정하는데 
        //노력을 쏟지말라 !!!)
        function DetailForm(props){
            
            function handleEdit(){
                //유효성 체크 후 수정 요청 

                //자바스크립트의 불리언 강제 변환 문법 
                /* 
                    !0  -       true
                    !1  -       false
                    !"" -       true
                    !"zino"    false
                    !null       true
                
                    !!의 의미 -  불리언 타입으로 강제 변환만 수행 

                    !!0                 false
                    !!1                 true
                    !!""                false
                    !!"abc"             true
                    !!undefined  false
                    !!{}            true    비어있기는 하지만, 객체는 존재함 그래서 논리값을 변환했을경우 true로 인정 
                */
                const selectedId = !! props.notice.noticeId;//noticeId에 값이 없을 경우엔  false로  처리 
                
                if(selectedId==false){
                    alert("수정하고싶은 게시물을 먼저 선택하세요");
                }    
                const payload={
                    title:"수정제목",
                    writer:"수정한자",
                    content:"수정내용 "    
                }
                
                props.onUpdate(props.notice.noticeId , payload); //props로 전달된  onUpdate 변수명이  update함수를 참조하므로...      
            }
            
            function handleDelete(){

            }

            return (
                <div className="detail">
                    <form>                        
                        <input type="text" value={props.notice.title}/>
                        <input type="text" value={props.notice.writer}/>        
                        <textarea value={props.notice.content}></textarea>
                        <button type="button" style={{width:"45%"}} onClick={handleEdit}>수정</button>
                        <button type="button" style={{width:"45%"}} onClick={handleDelete}>삭제</button>
                    </form>    
                </div>
            );            
        }            

        //자식 컴포넌트들을 조합하기 위한 부모 컴포넌트 정의 
        //추후 개발시 공통의 메서드나 컴포넌트가 변수의 공유등에 아주 필수적임
        function App(){
            //서버로부터 가져온 목록데이터를 화면에 표시할 UI와 엮게될 바인딩 변수 선언 
            const [noticeList, setNoticeList]=React.useState([]);
            
            //구조 분해 할당 
            const [notice, setNotice] = React.useState({
                 noticeId :"",
                 title:"",
                 writer:"",
                 content:"",
                 regdate:"",
                 hit:0                
            });
            function edit(){
                
            }                
            /*---------------------------------------------
            목록 가져오기 
            컴포넌트가 렌더링(화면에 등장) 된 직후에  실행해야 할 업무를 부수효과(side effect)를 다룰때 자주 사용되는 메서드 
            예) 렌더링 직후 서버 호출, DOM 접근 등.. 화면에 렌더링 직후 1회만 실행
            ---------------------------------------------*/
            React.useEffect(()=>{
                fetch("http://localhost:9999/api/notices", {method:"GET"})
                .then(res=>res.json())//첫번째 then() 서버에서 응답이 왔을때 수행됨 (단 이 응답이 성공인지 실패인지는 모름)
                           //만일 성공했다면, 서버로 부터 전달된 데이터는 아직 json문자열 형태가 아니므로, json문자열로 변경해보자    
                .then(data =>{ //여기서의 data는 첫번째 then에서 반환된 Promise가 resolve하면서 넘겨준 값
                    console.log("서버로 부터 받은 데이터는 ", data);
                    setNoticeList(data);
                })
                .catch(err => console.log(err));
            }, []);


            /*---------------------------------------------
            서버에 비동기로 글 등록 요청             
            ---------------------------------------------*/
            function regist(notice){

                //JQuery Ajax에 의존하지 않고, 브라우저 자체적으로 비동기 통신을 지원하는 기능이 fetch()
                //alert("나는 부모 컴포넌트인 App의 regist() 메서드 이다.");
                fetch("http://localhost:9999/api/notices", {
                    method:"POST", 
                    headers:{
                        "Content-Type" : "application/json"
                    },
                    body:JSON.stringify(notice) //마치 백엔드 스프링서버의 jackson과 비슷..
                })
                .then(res => res.json())
                .then(savedNotice => {
                    console.log("savedNotice is {}", savedNotice);
     
                })
                .catch(err => console.log(err)); 

            }

            /*---------------------------------------------
            상세보기
            ---------------------------------------------*/
            function selectOne(notice){
                //alert("부모인 App의 메서드 호출 성공'");
                //1) db에서 다시 불러오기 

                //2) 리스트 컴포넌트인 자식이, 현재 선택한 게시물 정보를 이쪽으로 넘김 
                console.log("자식 컴포넌트로부터 전달된 notice is ", notice);
                setNotice(notice);
            }

            /*---------------------------------------------
            수정하기
            ---------------------------------------------*/
            function update(noticeId, payload){
                //alert("부모컴포넌트인 App의 update() 호출");
                console.log("수정할 내용은 ", payload, " noticeId=", noticeId);

                //웹브라우저에서 지원하는 비동기 통신 함수, 장점? 외부 라이브러리인 JQuery에 의존하지 않음 
                
                fetch(`http://localhost:9999/api/notices/${noticeId}` , {
                    method:"PUT",
                    headers:{"Content-Type":"application/json"},
                    body:JSON.stringify(payload)  //객체는 그 자체를 네트워크로 전송할 수 없다. 반드시 문자열로 변경되어야 가능하다..
                })
                //서버로부터 응답이 오면, 아래의 then()이 수행, 하지만 수정 요청 자체가 성공  or 실패인지는 then() 안에서 판단해야함
                .then(res =>{
                    if(!res.ok) throw new Error("수정실패 ");
                    return res.json(); //서버가 json문자열을 전송했다는 전제로 이 메서드 호출 
                })
                .then( updated =>{
                    console.log("수정 결과로 응답받은 데이터 ", updated);
                })
                .catch( err =>{
                    console.log(err);
                });
            }

            return (
                <div id="wrapper">
                    <RegistForm bt="공지등록" onRegist={regist} />
                    <NoticeList noticeList={noticeList} onSelectOne={selectOne}/>
                    <DetailForm notice={notice} onUpdate={update}/>
                </div>
            )                
        }
        const root=ReactDOM.createRoot(document.getElementById("app"));        
        root.render( <App />);
    </script>        
</body>
</html>





